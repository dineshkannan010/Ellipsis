from flask import Blueprint, jsonify, request, current_app
from agent.generator import summarize_contents
from agent.voice import text_2_audio
from dotenv import load_dotenv
from flask_sse import sse
from threading import Thread
import re
from uuid import uuid4
import json


api_routes = Blueprint('api', __name__)

load_dotenv()

# a simple in‐memory flag store
_cancel_flags: dict[str, bool] = {}
# In-memory store (replace with DB in production)
connected_socials = []


@api_routes.route('/connect', methods=['POST'])
def connect_platform():
    platform = request.json.get('platform')
    if platform and platform not in connected_socials:
        connected_socials.append(platform)
        return jsonify({"message": f"{platform} connected"}), 200
    return jsonify({"error": "Invalid request or already connected"}), 400

@api_routes.route('/disconnect', methods=['POST'])
def disconnect_platform():
    platform = request.json.get('platform')
    if platform and platform in connected_socials:
        connected_socials.remove(platform)
        return jsonify({"message": f"{platform} disconnected"}), 200
    return jsonify({"error": "Invalid request or not connected"}), 400

@api_routes.route('/connected_platforms', methods=['GET'])
def get_connected_platforms():
    return jsonify({"connected_platforms": connected_socials}), 200


def _run_pipeline(query: str, app, job_id: str):
    # push the Flask app context so current_app works
    with app.app_context():

        if _cancel_flags.get(job_id):
            return

        # 1) Initial persona scripts
        sse.publish({"status": "initial_response_generation_started"}, type="status")
        responses, final_script = summarize_contents(query, sse)

        # 2) Publish final script
        formatted = "\n\n".join(f"**{sp}:** {ln}" for sp, ln in final_script)
        sse.publish({"script": formatted}, type="script")
        if _cancel_flags.get(job_id):
            return
        sse.publish({"status": "script_ready"}, type="status")
        
        if _cancel_flags.get(job_id):
            return
        
        # 4) Generate audio
        sse.publish({"status": "audio_generation_started"}, type="status")

        if _cancel_flags.get(job_id):
            return
        
        try:
            audio_file = text_2_audio(final_script)
            sse.publish({"audio": f"/audio/{audio_file}"}, type="audio")
            sse.publish({"status": "podcast_generated"}, type="status")
        except Exception as e:
            current_app.logger.exception("TTS generation failed")
            sse.publish({
                "status": "audio_error",
                "message": str(e)
            }, type="status")
            return



@api_routes.route('/generate', methods=['POST'])
def generate():
    data = request.json or {}
    query = data.get("query", "")

    # capture the true Flask app so the worker thread can push context
    app_obj = current_app._get_current_object()
    
     # 1) create a new job id + cancellation event
    job_id = str(uuid4())
    _cancel_flags[job_id] = False

    Thread(target=_run_pipeline, args=(query, app_obj, job_id), daemon=True).start()

    return jsonify(success=True, jobId=job_id), 202



@api_routes.route('/trending', methods=['GET'])
def trending():
    """
    Return a list of the current top 5 trending topics,
    as generated by Perplexity.
    """
    prompt = (
         "For our next podcast episode, list the top 5 currently trending topics on the internet in 2025.  "
        "For each topic, first give a concise title *of 3–4 words* that captures the essence, "
        "then follow with a one-sentence description.  "
        "Number them 1. – 5. with an em-dash (—) between title and description."
        "Only output exactly five lines.  "
        "Each line must look like:\n"
        "1. <Title of 3–4 words> — <one-sentence description>\n"
        "2. <Title of 3–4 words> — <one-sentence description>\n"
        "…up to 5.\n"
        "Do not include any extra text, markdown, headings, or blank lines."
    )

    try:
        from agent.generator import call_perplexity
        raw = call_perplexity(prompt)

        topics = []
        for line in raw.splitlines():
            line = line.strip()
            if not line:
                continue

            # capture “1. Title — Description” or “1. Title - Description”
            m = re.match(r'^\s*\d+\.\s*(.*?)\s*[—-]\s*(.*)$', line)
            if not m:
                continue

            title, desc = m.groups()

            # fallback if title is empty
            if not title.strip() and desc.strip():
                title, desc = desc, ""

            clean_title = title.strip()
            clean_desc = re.sub(r'\s*\[\d+(?:,\s*\d+)*\]\s*', ' ', desc).strip()

            topics.append({
                "title": clean_title,
                "description": clean_desc,
                "category": "Trending"
            })
            if len(topics) >= 5:
                break

    except Exception as e:
        current_app.logger.exception("Failed to fetch trending")
        return jsonify(error=str(e)), 500

    return jsonify(topics=topics)

@api_routes.route('/cancel', methods=['POST'])
def cancel():
    # read raw body, regardless of content-type
    raw = request.get_data(as_text=True)
    try:
        payload = json.loads(raw)
    except json.JSONDecodeError:
        return jsonify(error="Invalid JSON"), 400

    # accept either key name
    job_id = payload.get("jobId") or payload.get("job_id")
    if not job_id:
        return jsonify(error="Missing jobId"), 400

    if job_id in _cancel_flags:
        _cancel_flags[job_id] = True
        return "", 204

    return jsonify(error="Unknown job"), 404